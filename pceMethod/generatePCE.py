#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Fri Jan  5 09:29:20 2018
@author: Ohi Dibua
This file contains the function that finds the coefficients of the generalized polynomial chaos
expansion approximation of some input function, based on an arbitrary basis function. It is constructed
using integrals based on smolyak's cubature as illustrated in Section 2.3.4 in [1]. The PCE expansion 
of a functio is as follows:   
    f(x) = sum(Bk*Pk(x1,x2,...xd)) where Bk are the coefficients, Pk are the orthogonal basis polynomials, and xi 
    are the input variables to the function, x, being approximated. x is classically thought of as an uncertain
    variable.    
The function genPCEIntegral takes as arguments:
    p: Integer that is the highest power allowed for the basis polynomial as a function of a single input 
    d: Integer that yields dimension of the input 
    level: Accuracy level that dictates the number and location of nodes and weights generated using smolyak's cubature
    basisPolynomial: Orthogonal polynomial used in approximating the function over some range of inputs. This function is 
                     currently written under the assumption that Legendre polynomials are being used.                     
and it returns:
    beta: Coefficients of expansions
    Polynomials: Associated orthogonal polynomials
    nodes: Location of integration points generated by smolyak cubature
    weights:  Weights associated with nodes generated by smolyak cubature
    powList: List of powers of input dimension that exist in the associated polynomial in Polynomials.
             Used for calculating sobolIndices
[1] T. Crestaux, O. Maitre, J-M Martinez, "Polynomial Chaoes expansion for sensitivity analysis," 
    Reliability Engineering and System Safety, 2008
"""
import numpy as np
import math
import copy
from obtainPolynomialPowers import validPowersRecur
from kpusmolyak import *
import scipy.integrate.quadrature
 
def genPCEIntegral(p,d,level,basisPolynomial,func): 
    # Define total number of coefficients, initialize power list, and define smolyak integration class       
    P = math.factorial(p+d)/(math.factorial(p)*math.factorial(d));
    powList = []; integral = performIntegral();
    
    # Generate list of powers to be used to construct each polynomial in the expansion using 
    # a permutation recursion
    powList.append(copy.deepcopy(np.array([0.0]*d)));
    for j in range(p):
        powArray = np.array([0.0]*d);
        target = j+1; 
        index=0;
        powOptions=np.array(range(target+1)); 
        validPowersRecur(powOptions,index,target,powArray,powList) 
    
    # Generate nodes and weights to be used in the integration, and use a linear
    # transformation to transform nodes into domain expected by Legendre polynomial
    nodes, weights = copy.deepcopy(integral.obtainNodesandWeightsKPU(d,level));
    nNodes=np.shape(nodes)[0];
    lb=-1; ub=1; #ASSUMES legendre polynomials
    nodes = (ub-lb)*nodes+lb
    
    #Performs inner product calculations to obtain the coefficients of the PCE expansion
    #Stores polynomials and their inner product
    beta = [0.0]*P;
    integralArr = [0.0]*P
    for k in range(P):      
        if (k==0): 
            f=np.array([0.0]*nNodes)
            for j in range(nNodes):
                f[j]=func(nodes[j]);                
        polynomial=np.array([0.0]*nNodes)
        for l in range(nNodes):
            poly=1.0;
            for j in range(d):
                poly=poly*basisPolynomial(powList[k][j],np.array([nodes[l][j]]));
            polynomial[l]=poly
        
        integralArr[k] = integral.integrate(
                weights,[polynomial[l]*polynomial[l] for l in range(nNodes)])
        
        beta[k] = integral.integrate(weights,[polynomial[l]*f[l] for l in range(nNodes)])/integral.integrate(
                weights,[polynomial[l]*polynomial[l] for l in range(nNodes)])  

    return (beta,polynomial,nodes,weights,powList,integralArr) 
         

